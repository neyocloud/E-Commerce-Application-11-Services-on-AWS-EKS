pipeline {
  agent any

  parameters {
    booleanParam(name: 'AUTO_APPLY', defaultValue: false, description: 'If true, auto-apply without manual approval')
  }

  options {
    timestamps()
    durabilityHint('MAX_SURVIVABILITY')                 // better resume after restarts
    timeout(time: 90, unit: 'MINUTES')                  // global cap
    buildDiscarder(logRotator(daysToKeepStr: '7', numToKeepStr: '10'))
  }

  environment {
    TF_IN_AUTOMATION     = '1'
    TF_PLUGIN_CACHE_DIR  = '/var/lib/jenkins/.terraform.d/plugin-cache'
    AWS_REGION           = 'us-east-1'
  }

  stages {
    stage('Checkout from Git') {
      steps {
        // use the job's SCM config
        checkout scm
      }
    }

    stage('Preflight: network') {
      steps {
        timeout(time: 2, unit: 'MINUTES') {
          sh '''
            set -euxo pipefail
            mkdir -p "$TF_PLUGIN_CACHE_DIR"
            echo '=== Network snapshot ==='
            uname -a; date; ip route; cat /etc/resolv.conf || true

            echo '=== Testing endpoints (DNS+TLS) ==='
            for url in https://registry.terraform.io https://releases.hashicorp.com https://objects.githubusercontent.com; do
              echo "--- $url ---"
              curl -sS -I --connect-timeout 3 --max-time 8 "$url" >/dev/null
            done

            echo '=== AWS identity (non-fatal) ==='
            aws sts get-caller-identity || true
          '''
        }
      }
    }

    stage('Terraform version') {
      steps {
        sh 'terraform --version'
      }
    }

    stage('Terraform init') {
      steps {
        dir('eks-terraform') {
          retry(2) {
            timeout(time: 20, unit: 'MINUTES') {
              sh 'terraform init -input=false -no-color --reconfigure'
            }
          }
        }
      }
    }

    stage('Terraform validate') {
      steps {
        dir('eks-terraform') {
          retry(2) {
            timeout(time: 10, unit: 'MINUTES') {
              sh '''
                set -euxo pipefail
                pwd; ls -la
                terraform validate -no-color -json | tee ../tf-validate.json
              '''
            }
          }
        }
      }
      post {
        always {
          archiveArtifacts artifacts: 'tf-validate.json', allowEmptyArchive: true
        }
      }
    }

    stage('Terraform plan') {
      steps {
        // Jenkins credential of type "AWS Credentials" with ID: aws-access-key
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-access-key']]) {
          dir('eks-terraform') {
            retry(2) {
              timeout(time: 20, unit: 'MINUTES') {
                sh '''
                  set -euxo pipefail
                  aws sts get-caller-identity
                  terraform plan -no-color -out=tfplan.bin | tee ../tf-plan.txt
                '''
              }
            }
          }
        }
      }
      post {
        always {
          archiveArtifacts artifacts: 'eks-terraform/tfplan.bin, tf-plan.txt', allowEmptyArchive: true
        }
      }
    }

    stage('Terraform apply') {
      when { expression { return params.AUTO_APPLY } }
      steps {
        input message: 'Apply the plan to AWS?', ok: 'Yes, apply'
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-access-key']]) {
          dir('eks-terraform') {
            timeout(time: 30, unit: 'MINUTES') {
              sh '''
                set -euxo pipefail
                terraform apply -no-color -auto-approve tfplan.bin | tee ../tf-apply.txt
              '''
            }
          }
        }
      }
      post {
        always {
          archiveArtifacts artifacts: 'tf-apply.txt', allowEmptyArchive: true
        }
      }
    }
  }

  post {
    always {
      sh 'echo Build finished at $(date)'
      cleanWs(deleteDirs: true)
    }
  }
}
