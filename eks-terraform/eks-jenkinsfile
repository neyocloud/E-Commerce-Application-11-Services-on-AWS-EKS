pipeline {
  agent any

  options {
    timestamps()
    ansiColor('xterm')
    durabilityHint('MAX_SURVIVABILITY')           // survive controller restarts
    timeout(time: 90, unit: 'MINUTES')            // global cap
    buildDiscarder(logRotator(daysToKeepStr: '7', numToKeepStr: '10'))
  }

  parameters {
    booleanParam(name: 'AUTO_APPLY', defaultValue: false, description: 'If true, auto-apply without manual approval')
  }

  environment {
    TF_IN_AUTOMATION     = '1'
    TF_PLUGIN_CACHE_DIR  = '/var/lib/jenkins/.terraform.d/plugin-cache'
    AWS_REGION           = 'us-east-1'            // change if needed
    // Jenkins JVM tmp was moved to /var/lib/jenkins/tmp already
  }

  stages {

    stage('Checkout from Git') {
      steps {
        checkout scm
      }
    }

    stage('Preflight: network') {
      steps {
        timeout(time: 2, unit: 'MINUTES') {
          sh '''
            set -euxo pipefail
            mkdir -p "$TF_PLUGIN_CACHE_DIR"
            echo '=== Network snapshot ==='
            uname -a; date; ip route; cat /etc/resolv.conf

            echo '=== Testing endpoints (DNS+TLS) ==='
            for url in https://registry.terraform.io https://releases.hashicorp.com https://objects.githubusercontent.com; do
              echo "--- $url ---"
              curl -sS -v --connect-timeout 3 --max-time 8 -I "$url" >/dev/null
            done

            echo '=== AWS identity (non-fatal) ==='
            aws sts get-caller-identity || true
          '''
        }
      }
    }

    stage('Terraform version') {
      steps {
        sh 'terraform --version'
      }
    }

    stage('Terraform init') {
      steps {
        dir('eks-terraform') {
          retry(2) {
            timeout(time: 20, unit: 'MINUTES') {
              sh 'terraform init -input=false -no-color --reconfigure'
            }
          }
        }
      }
    }

    stage('Terraform validate') {
      steps {
        dir('eks-terraform') {
          retry(2) {
            timeout(time: 10, unit: 'MINUTES') {
              sh '''
                set -euxo pipefail
                pwd; ls -la
                terraform validate -no-color -json | tee ../tf-validate.json
              '''
            }
          }
        }
      }
    }

    stage('Terraform plan') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-secret']]) {
          dir('eks-terraform') {
            retry(2) {
              timeout(time: 20, unit: 'MINUTES') {
                sh '''
                  set -euxo pipefail
                  aws sts get-caller-identity
                  terraform plan -no-color -out=tfplan.bin | tee ../tf-plan.txt
                '''
              }
            }
          }
        }
      }
    }

    stage('Terraform apply') {
      when { expression { return params.AUTO_APPLY } }
      steps {
        input message: 'Apply the plan to AWS?', ok: 'Yes, apply'
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-secret']]) {
          dir('eks-terraform') {
            timeout(time: 30, unit: 'MINUTES') {
              sh '''
                set -euxo pipefail
                terraform apply -no-color -auto-approve tfplan.bin | tee ../tf-apply.txt
              '''
            }
          }
        }
      }
    }
  }

  post {
    always {
      archiveArtifacts artifacts: 'tf-*.txt, **/terraform.tfstate*', fingerprint: true, allowEmptyArchive: true
      cleanWs()
    }
  }
}
